<!--
 * @Author: liming
 * @Date: 2021-08-10 16:13:05
 * @LastEditTime: 2021-08-10 16:50:11
 * @FilePath: \04-王红元(一般)\02-代码手敲\01_learn_react\00_语法补充\02_JS中类的继承.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
        /**
         * 面向对象有三大特性: 封装\继承\多态
         * 继承: 1.减少重复的代码 2.多态的前提(鸭子类型)——如果一个东西看起来像鸭子，走起路来也像鸭子，那它就是鸭子
         * JS中提现的不是很好，但又可以说它到处都是多态
         */
        // function sum(num1,num2){
        //     return num1 + num2
        // }

        // sum(20, 30);
        // sum(20.5,30.5)
        // sum('abc','def')

        //js不好的地方，太灵活了，也不好

        class Person{
            constructor(name,age){
                this.name = name
                this.age = age
            }
            running() {
                console.log('Person running');
            }
        }

      //   class Student{
      //       constructor(name,age,sno){
      //           this.name = name
      //           this.age = age
      //           this.sno = sno;
      //       }

      //         running() {
      //           console.log('running');
      //       }

      //   }

      //   class Teacher{
      //       constructor(name,age,title){
      //           this.name = name
      //           this.age = age
      //           this.title = title;
      //       }

      //         running() {
      //           console.log('running');
      //       }
      //   }

        //一般这样写重复代码太多了，可以使用继承的写法
          class Student extends Person{
              constructor(name, age,sno){
                  super(name,age)
                  //super表示超级的意思，父类也叫超类
                  // super(name,age)到时候会调用父类的构造方法，你就不用自己写了，方便
                  // super(name,age)等价于 this.name = name, this.age = age
                  this.sno = sno;
                   //【注意】在构造器中如果有继承的话，super是必须要调用的！！！！
                  //因为它要【初始化】一下父类的对象
              }

              //因为我们使用了继承，到时候学生会自动继承running方法的
              // 如果你的running方法和父类不一样，也可以进行重写
              running() {
                  //方法重写
                  console.log('学生跑步');
              }
          }

          const stu = new Student('why',18,110)
          console.log(stu);
          console.log(stu.name);
          console.log(stu.age);
          console.log(stu.sno);
          stu.running()

          class Teacher extends Person{
              constructor(name, age,title){
                  super(name,age)
                //   super(age,name)
                  //子类中必须初始化父类的对象的
                 this.title = title;
              }
              
          }

          const teacher = new Teacher('kobe',40,'教练')
        //Must call super constructor in derived class before accessing 'this' or returning from derived constructor
        console.log(teacher);
        console.log(teacher.name);
        console.log(teacher.age);
        console.log(teacher.title);
    </script>
  </body>
</html>