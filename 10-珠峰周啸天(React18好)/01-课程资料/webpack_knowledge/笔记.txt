JS中的模块化规范：模块的导入和导出
  1. 单例设计模式：早期实现模块化开发的一种解决方案
    优势：
      + 基于闭包进行管理，可以确保各个模块之间的代码不冲突，避免全局变量污染
      + 把需要供他人调用的方法导出，基于命名空间获取，这样保证了模块之间的相互访问
    弊端：
      + 需要先手动分析模块之间的依赖{这是一个非常复杂的工作}，然后按照顺序依次导入JS
  
  2. AMD模块化思想「插件：require.js」
    AMD是一种按需导入的思想，在保留了“防止全局变量污染 & 模块之间可以相互访问”的基础上，构建了一套相对比较简单的依赖处理机制！！
    弊端：模块的导入属于“前置导入”
      + 必须先把依赖的模块导入进来后，才可以处理自己模块中的代码
      + 需要依赖的模块，都必须写在最前面
    -----
    @1 基于 define 方法创建模块
    define([需要依赖的其它模块], function(基于形参接收依赖的模块信息) {
        'use strict';
        // 自己模块中需要些的代码

        // 模块的导出
        return {
            ...
        };
    });

  3. CommonJS模块化规范
    优势：非常好用，我们期望的“一套完善的模块化处理方案”，CommonJS都具备！「既可以保证模块之间的独立性，也允许相互访问；使用更简单（不用依赖啥插件）；还可以有效的处理模块之间的依赖，最好实现按需导入...」
    弊端：只能在Node端运行，浏览器不支持！！
    -----
    @1 创建模块：创建一个JS，就是创建一个模块
    @2 导出：module.exports
    @3 导入：require

  4. CMD模块化思想「插件：sea.js（淘宝·玉伯）」
    本质：把CommonJS规范搬到浏览器端运行

  5. ES6中新增了内置的模块化解决方案：ES6Module
    无需安装插件，只要支持ES6语法的浏览器，都可以使用ES6Module规范，实现模块之间的管理！
    -----
    @1 创建模块：创建一个JS，就是创建一个模块
    @2 导出：export / export default
    @3 导入：import
    
=================================
Webpack的使用
  @1 安装webpack
    $ npm i webpack webpack-cli
    + 不安装在全局：防止版本冲突
    + 本地如何使用命令：首先确保node_modules/.bin具备执行的命令，其次在package.json的scripts中配置可执行的脚本命令！！
      "scripts": {
        "start": "webpack"
      },
    $ npm run start

  @2 webpack有默认的打包规则「零配置启动」
    默认找当前目录src下的index.js，把其作为入口文件，计算模块之间的依赖关系，最后实现模块的合并、压缩、打包等功能！！
    + 默认入口：src/index.js
    + ES6Module规范，可以省略导入文件的后缀
    + 默认出口：dist/main.js
    + 默认基于terser-webpack-plugin实现代码的压缩
    + webpack5之后开启了 tree shaking 功能：打包的时候，自动剪掉了没用到的内容
    + ...

  @3 真实开发的时候，我们一定会自己设置webpack的打包规则，让其具备更多的打包效果
    在项目根目录下，我们新建一个文件 webpack.config.js，在这里定义自己的打包规则；每当执行webpack这个命令的时候，会自动去这个文件中进行查找，按照我们配置的规则进行打包！！
    